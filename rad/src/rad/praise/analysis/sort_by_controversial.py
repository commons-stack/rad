from importlib.metadata import distribution
from ..distribution.standard_praise import PraiseDistribution
import plotly.express as px
import numpy as np
import pandas as pd
from IPython.display import Markdown, display
import json


# header = "# Histogram"
# description = f"This is a histogram of the { self.objectName} object. It's stored in /reward_systems/straight_distribution as a regular python module. Apart from perfoming the analysis, it can also output a visual representation with a specific header (above) and description text. "
author = "Nuggan"
Last_updated = "2022."
version = ""


def run(praise_distribution_data, _config={}):
    """
    Runs the main module function: a histogram of the reward distribution among users of the reward system

    Args:
        praise_distribution_data: The object with the reward distribuiton system
    Raises:
        [TODO]: Check for errors and raise them
    Returns:
        res: a DataFrame with the requested results. Contains two columns, "ID" and "AMOUNT TO RECEIVE"

    """
    # print(praise_distribution_data)
    # distribution = PraiseDistribution.generate_from_dict(praise_distribution_data)
    distribution = pd.DataFrame(
        praise_distribution_data.praiseInstance.dataTable
    ).copy()

    NUMBER_OF_QUANTIFIERS_PER_PRAISE = (
        praise_distribution_data.praiseInstance.quantPerPraise
    )

    col_dismissed = [
        f"DISMISSED {k+1}" for k in range(NUMBER_OF_QUANTIFIERS_PER_PRAISE)
    ]
    col_dupids = [
        f"DUPLICATE ID {k+1}" for k in range(NUMBER_OF_QUANTIFIERS_PER_PRAISE)
    ]
    col_scores = [f"SCORE {k+1}" for k in range(NUMBER_OF_QUANTIFIERS_PER_PRAISE)]

    # clean the Dataframe and remove praise where there is dismissal agreement
    praisecheck_df = distribution.drop(
        [
            "TO ETH ADDRESS",
            "TO USER ACCOUNT ID",
            "FROM ETH ADDRESS",
            "FROM USER ACCOUNT ID",
            "SOURCE ID",
            "SOURCE NAME",
            "PERCENTAGE",
        ],
        axis=1,
    )
    ethadds = [
        f"QUANTIFIER {k+1} ETH ADDRESS" for k in range(NUMBER_OF_QUANTIFIERS_PER_PRAISE)
    ]
    praisecheck_df.drop(ethadds, axis=1, inplace=True)

    praisecheck_clean_controversial = praisecheck_df.loc[
        praisecheck_df[col_dismissed].sum(axis=1) < NUMBER_OF_QUANTIFIERS_PER_PRAISE, :
    ]

    # reinstate the original scores for the duplicates before calculating the spread
    dupclean_praisecheck = praisecheck_clean_controversial.copy()
    for i, row in praisecheck_clean_controversial.iterrows():
        for j, dup_id_label in enumerate(col_dupids):

            if type(row[dup_id_label]) is str:
                # find the score
                find_value = praisecheck_df.loc[
                    praisecheck_df["ID"] == row[dup_id_label], col_scores[j]
                ]

                try:
                    # substitute it in dupclean
                    dupclean_praisecheck.at[i, str(col_scores[j])] = int(find_value)
                except:
                    # account for the bug in early rounds
                    dupclean_praisecheck.at[i, str(col_scores[j])] = 0

                    # discard no-shows (score = 0 and not dismissed, after the above check for duplicates) and calculate spread

    for i, score_col in enumerate(col_scores):
        dupclean_praisecheck[score_col] = dupclean_praisecheck.apply(
            lambda x: noShow(x[score_col], x[col_dismissed[i]]), axis=1
        )

    dupclean_praisecheck["SPREAD"] = dupclean_praisecheck[col_scores].max(
        axis=1
    ) - dupclean_praisecheck[col_scores].min(axis=1)
    sort_by_controversial = dupclean_praisecheck.sort_values(
        by="SPREAD", ascending=False
    ).reset_index()

    sort_by_controversial["MAX SCORE"] = sort_by_controversial[col_scores].max(axis=1)

    return sort_by_controversial


def noShow(a, b):
    if int(a) == 0 and bool(b) == False:
        return np.nan
    else:
        return a


def printDescription(praise_distribution_data, _config={}):
    """
    Prints the description of the analysis module to be displayed above the graph

    Args:
        praise_distribution_data: The object with the reward distribuiton system
    Raises:
        [TODO]: Check for errors and raise them
    Returns:
        nothing, it prints the texts

    """
    # name = praise_distribution_data["name"]
    name = praise_distribution_data.name
    # header = f'# "{name}" Histogram'
    description = f"TODO Sort by controversial description text. "

    # display(Markdown(header))
    display(Markdown(description))


def printGraph(praise_distribution_data, _config={"x":"SPREAD", "y":["MAX SCORE"]}):
    """
    Prints a visualization of the histogram generated by run(). This function is itended to be called from inside the jupyter notebook

    Args:
        praise_distribution_data: The object with the reward distribuiton system
    Raises:
        [TODO]: Check for errors and raise them
    Returns:
        nothing, it prints the figure

    """

    sort_by_controversial = pd.DataFrame(run(praise_distribution_data))

    x_row = _config["x"]
    y_rows = _config["y"]


    spread_df = sort_by_controversial[
        ["REASON", "AVG SCORE", "MAX SCORE", "SPREAD"]
    ].sort_values(by="SPREAD")

    fig = px.scatter(spread_df,x=x_row, y=y_rows, hover_name="REASON")
    fig.show()
